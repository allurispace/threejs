<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - extrude shapes from geodata</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		</style>
	</head>

	<body>

		<script type="text/javascript" src="./three.min.js"></script>
		<script type="text/javascript" src="./ColladaLoader.js"></script>

		<script>
			// From d3-threeD.js
			/* This Source Code Form is subject to the terms of the Mozilla Public
			 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
			 * You can obtain one at http://mozilla.org/MPL/2.0/. */
			// Main
			var renderer;
      var mixer;
      keepanimate = true;
      var clock
			var scene, group;
			var targetRotation = 0;
			var targetRotationOnMouseDown = 0;
			var mouseX = 0;
			var mouseXOnMouseDown = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var container = document.createElement( 'div' );
			document.body.appendChild( container );
			var info = document.createElement( 'div' );
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'click to toggle';
            info.onclick = (e) => {keepanimate = !keepanimate};
			container.appendChild( info );
			init();
			container.appendChild( renderer.domElement );
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			document.addEventListener( 'touchmove', onDocumentTouchMove, false );
			window.addEventListener( 'resize', onWindowResize, false );
			animate();
			//
			function init() {
				/// Global : renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xb0b0b0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				/// Global : scene
				scene = new THREE.Scene();
				/// Global : camera
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set(0, -150, 80);
        camera.lookAt(scene.position);
				/// Global : group
				group = new THREE.Group();
				scene.add( group );
				/// direct light
				var light = new THREE.DirectionalLight( 0x404040 );
				light.position.set( 0.75, 0.75, 1.0 ).normalize();
				scene.add( light );
				/// ambient light
				var ambientLight = new THREE.AmbientLight(0x404040);
				scene.add( ambientLight );
				/// backgroup grids
				var helper = new THREE.GridHelper( 160, 10 );
				helper.rotation.x = Math.PI / 2;
				group.add( helper );
               /* var geometrye = new THREE.BoxBufferGeometry(15, 40, 5);
                var materiale = new THREE.MeshBasicMaterial({ color: 0xC07000});
                var mesh = new THREE.Mesh(geometrye, materiale);
                group.add(mesh); */
                
        var loader = new THREE.ColladaLoader();

        loader.load(
          // resource URL
          './iphone6.dae',
          // Function when resource is loaded
          function ( collada ) {
            var object = collada.scene;
			object.scale.set( 0.7, 0.7, 0.7 );

            var box = new THREE.Box3().setFromObject( object );
            box.center( object.position ); // this re-sets the mesh position
            object.position.multiplyScalar( - 1 );

            var pivot = new THREE.Group();
            group.add( pivot );
            pivot.add( object );
            
            
            
                    // POSITION
        var positionKF = new THREE.VectorKeyframeTrack('.position', [0, 1, 2], [0, 0, 10, -20, 0, -40, 0, 0,10]);


        // ROTATION
        // Rotation should be performed using quaternions, using a QuaternionKeyframeTrack
        // Interpolating Euler angles (.rotation property) can be problematic and is currently not supported

        // set up rotation about x axis
        var xAxis = new THREE.Vector3(1, 0, 0);
        var yAxis = new THREE.Vector3(0, 1, 0);

        var qInitial = new THREE.Quaternion().setFromAxisAngle(xAxis, 0);
        var qFinal = new THREE.Quaternion().setFromAxisAngle(xAxis, Math.PI/2);
        var qfinaly = new THREE.Quaternion().setFromAxisAngle(yAxis, Math.PI);
        var quaternionKF = new THREE.QuaternionKeyframeTrack('.quaternion', [0, 1, 2], [qInitial.x, qInitial.y, qInitial.z, qInitial.w, qFinal.x, qFinal.y, qFinal.z, qFinal.w, qInitial.x, qInitial.y, qInitial.z, qInitial.w]);

        // create an animation sequence with the tracks
        // If a negative time value is passed, the duration will be calculated from the times of the passed tracks array
        //var clip = new THREE.AnimationClip('Action', 3, [positionKF, quaternionKF]);
        var clip = new THREE.AnimationClip('Action', 3, [ positionKF,quaternionKF]);
        // setup the AnimationMixer
        mixer = new THREE.AnimationMixer(pivot);

        // create a ClipAction and set it to play
        clipAction = mixer.clipAction(clip);
        clipAction.play();
				clock = new THREE.Clock();
            
            
            
          },
          // Function called when download progresses
          function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
          }
        );
                
        // create a keyframe track (i.e. a timed sequence of keyframes) for each animated property
        // Note: the keyframe track type should correspond to the type of the property being animated


  
			}
		
			/// Events from extrude shapes example
			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function onDocumentMouseDown( event ) {
				event.preventDefault();
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );
				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;
			}
			function onDocumentMouseMove( event ) {
				mouseX = event.clientX - windowHalfX;
				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
			}
			function onDocumentMouseUp( event ) {
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}
			function onDocumentMouseOut( event ) {
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}
			function onDocumentTouchStart( event ) {
				if ( event.touches.length == 1 ) {
					event.preventDefault();
					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;
				}
			}
			function onDocumentTouchMove( event ) {
				if ( event.touches.length == 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
				}
			}
			function animate() {
				/// compatibility : http://caniuse.com/requestanimationframe
				requestAnimationFrame( animate );
				render();
			}
			function render() {
				group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
        var delta = clock.getDelta();

  if (mixer&&keepanimate) {

    mixer.update(delta);

  }
				renderer.render( scene, camera );
			}


		</script>

	</body>
</html>